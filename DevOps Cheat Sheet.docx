------------------------------------------------------------------
				Git
------------------------------------------------------------------

git config --global user.name "Sarang"
git config --global user.email "sarangrana@gmail.com"
git config --list



git clone https://github.com/sarangrana/godrepo.git
git clone git@github.com:sarangrana/godrepo.git
git status
git add <file-name>
git commit -m "Multiple Instance Code Implemented"




------------------------------------------------------------------
				Kubernetes
------------------------------------------------------------------
1. To remotely access your cluster from another machine
get content of the admin.conf file from /etc/kubernetes/
now on remote machine from which you need to connect, copy this file as "~/.kube/config"

2. To view username and password
kubectl config view will show the user/password you are using when using the kubectl tool.

3.Setting up username and password
kubectl config set-credentials cluster-admin --username=admin --password=admin

4. How to check which pod is running on which node?
kubectl get pods -o wide

5. To access the cluster
gcloud container clusters get-credentials jirautil-cluster --zone us-central1-a --project <project-name>

6. To get cluster information about master, kubeDNS, kubeProxy and kubernetes dashboard
kubectl cluster-info

6. kubectl describe pod <pod-name>
	- to have details about pod


kubectl config use-context <your-context>
kubectl get nodes
kubectl get cs 
	- will show component status
kubectl run <deployment-name> --image=<image-name> --port=80
kubectl get deployments
kubectl expose deployment <deployment-name> --target-port=80 --type=NodePort

kubectl create -f <your-file>.yml
kubectl get pods
kubectl describe pod <pod-name>
kubectl expose pod <pod-name> --type=NodePort
kubectl get svc
kubectl describe svc <your-pod>
	- will give you all details of the service exposed for pods




gcloud container clusters list
	- shows list of clusters
gcloud container clusters get-credentials <cluster-name>



PODS
REPLICA CONTROLLER
REPLICA SET
DEPLOYMENTS





1. kubectl version
	- To check kubernetes version
2. kubectl run <pod-name> --image=<image-name> --port=<port-number>
	- To run a pod from an image on exposing defined port
3. kubectl expose deployment <pod-name> --type=<service-type>
	- To expose deployment, here there are 3 options for <service-type> which are 1.ClusterIP, 2.NodePort, 3.LoadBalancer
4. kubectl get pod
	- To view pods and their status
5. kubectl delete deployment <deployment-name>
	- To delete the deployment
6. kubectl create -f <yaml-file-location>
	- To create new deployment via yaml file
7. kubectl get deployments
	- To list all deployments
8. kubectl describe deployment <deployment-name>
	- To have a detailed view of deployment
9. kubectl get deployment <deployment-name> -o yaml
	- To get yaml generated by kubernetes for given deployment
10. kubectl set image deployment/<deployment-name> <pod-name>=<image-name>:<image-tag>
	- To set image for a given pod running in given deployment
11. kubectl apply -f <yaml-file-location>
	- To update deployment via yaml file
12. kubectl create namespace <namespace-name>
	- To create namespace
kubectl get namespaces
	- To view all namespaces
13. kubectl --namespace=<insert-namespace-name-here> get pods
	- To perform any operation for given namespace
14. kubectl config set-context $(kubectl config current-context) --namespace=<insert-namespace-name-here>

# Validate it
kubectl config view | grep namespace:
	- To set namespace permanently

15. kubectl get pods -l environment=production,tier=frontend
	- To get objects as per the labels 
16. kubectl run nginx --image nginx
	or
    kubectl create deployment nginx --image nginx

	- Run an instance of the nginx container by creating a Deployment object.
17. kubectl delete -f nginx.yaml -f redis.yaml
	- Delete the objects defined in two configuration files
18. kubectl replace -f nginx.yaml
	- Update the objects defined in a configuration file by overwriting the live configuration
19. kubectl get roles
	- To view all the roles configured
20. kubectl get rolebinding SERVICE_ACCOUNT_NAME POD
	- To view all role binding configurations
21. kubectl get clusterrolebinding SERVICE_ACCOUNT_NAME POD
	- To view all the clusterrole bindings
22. kubectl create serviceaccount <service-account-name> --namespace mynamespace
	- To create service account
23. gcloud info | grep Account
	- To know which account you are logged in for Kubernetes
24. kubectl get clusterroles
	- To know the cluster roles
25. gcloud config list
	- To know which user is logged in
26. gcloud config set project <project-name>
	- To set/update project in config
27. kubectl create clusterrolebinding cluster-admin-binding --clusterrole cluster-admin --user $(gcloud config get-value account)
	- To give cluster-admin role to given user
28. kubectl auth can-i get pods --namespace qa --as system:serviceaccount:qa:sa-qa


PODS
$ kubectl get pods
$ kubectl get pods --all-namespaces
$ kubectl get pod monkey -o wide
$ kubectl get pod monkey -o yaml
$ kubectl describe pod monkey
Create Deployments
Create single deployment
$ kubectl run monkey --image=monkey --record
Scaling PODs
$ kubectl scale deployment/POD_NAME --replicas=N
POD Upgrade and history
List history of deployments
$ kubectl rollout history deployment/DEPLOYMENT_NAME
Jump to specific revision
$ kubectl rollout undo deployment/DEPLOYMENT_NAME --to-revision=N
Services
List services
$ kubectl get services
Expose PODs as services (creates endpoints)
$ kubectl expose deployment/monkey --port=2001 --type=NodePort
Volumes
Lits Persistent Volumes and Persistent Volumes Claims:
$ kubectl get pv
$ kubectl get pvc
Secrets
$ kubectl get secrets
$ kubectl create secret generic --help
$ kubectl create secret generic mysql --from-literal=password=root
$ kubectl get secrets mysql -o yaml
ConfigMaps
$ kubectl create configmap foobar --from-file=config.js
$ kubectl get configmap foobar -o yaml
DNS
List DNS-PODs:
$ kubectl get pods --all-namespaces |grep dns
Check DNS for pod nginx (assuming a busybox POD/container is running)
$ kubectl exec -ti busybox -- nslookup nginx
Note: kube-proxy running in the worker nodes manage services and set iptables rules to direct traffic.
Ingress
Commands to manage Ingress for ClusterIP service type:
$ kubectl get ingress
$ kubectl expose deployment ghost --port=2368
Spec for ingress:
backend
Horizontal Pod Autoscaler
When heapster runs:
$ kubectl get hpa
$ kubectl autoscale --help
DaemonSets
$ kubectl get daemonsets
$ kubectl get ds
Scheduler
NodeSelector based policy:
$ kubectl label node minikube foo=bar
Node Binding through API Server:
$ kubectl proxy 
$ curl -H "Content-Type: application/json" -X POST --data @binding.json http://localhost:8001/api/v1/namespaces/default/pods/foobar-sched/binding
Tains and Tolerations
$ kubectl taint node master foo=bar:NoSchedule
Troubleshooting
$ kubectl describe
$ kubectl logs
$ kubectl exec
$ kubectl get nodes --show-labels
$ kubectl get events
Docs Cluster:
https://kubernetes.io/docs/tasks/debug-application-cluster/debug-cluster/
https://github.com/kubernetes/kubernetes/wiki/Debugging-FAQ
Role Based Access Control
Role
ClusterRule
Binding
ClusterRoleBinding
$ kubectl create role fluent-reader --verb=get --verb=list --verb=watch --resource=pods
$ kubectl create rolebinding foo --role=fluent-reader --user=minikube
$ kubectl get rolebinding foo -o yaml
Security Contexts
Docs: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
spec
securityCOntext
runAsNonRoot: true
Pod Security Policies
Docs: https://github.com/kubernetes/kubernetes/blob/master/examples/podsecuritypolicy/rbac/README.md
Network Policies
Network isolation at Pod level by using annotations
$ kubectl annotate ns <namespace> "net.beta.kubernetes.io/network-policy={\"ingress\": {\"isolation\": \"DefaultDeny\"}}"







------------------------------------------------------------------
				LINUX
------------------------------------------------------------------

1. Find files having the text
find . -type f -print | sed 's/ /\\ /g' | xargs grep -i "your text here"

2. Find files via filename
locate <file-name>

3. To check port status
sudo netstat -ntlp










------------------------------------------------------------------
				NGINX
------------------------------------------------------------------

1. homepage of nginx : /usr/share/nginx/html/index.html
2. config file of nginx : /etc/nginx/nginx.conf



------------------------------------------------------------------
				DOCKER
------------------------------------------------------------------
1. docker version
	1. docker -v
		- short description
	2. docker --version
		- short description
	3. docker version
		- long description

2. docker info
	- gives you more details like configured account of docker registry etc.

3. Docker run <imagename>
	- To run a container from an image

4. docker image ls
	- to list the images on machine

5. docker rmi $(docker images -q)
	- Delete all images

6. docker rm $(docker ps -a -q)
	- Delete all containers

7. docker build -t <image-name-you-want> .
	- will build the image as per the Dockerfile specified and giving friendly name to docker image

8. docker run -p 4000:80 <image-name>	
	- To run image from local machine which has been saved previously

9. docker push username/repository:tag
	- Pushing image to docker registry
	- 

10. docker login
	- login to your docker hub account

11. docker compose-ps
	- shows running containers with name, command, state and open ports

## List Docker CLI commands
docker
docker container –help

## Display Docker version and info
docker --version
docker version
docker info

## Execute Docker image
docker run hello-world

## List Docker images
docker image ls

## List Docker containers (running, all, all in quiet mode)
docker container ls
docker container ls --all
docker container ls -aq

docker build -t friendlyhello .  # Create image using this directory's Dockerfile
docker run -p 4000:80 friendlyhello  # Run "friendlyname" mapping port 4000 to 80
docker run -d -p 4000:80 friendlyhello         # Same thing, but in detached mode
docker container ls                                # List all running containers
docker container ls -a             # List all containers, even those not running
docker container stop <hash>           # Gracefully stop the specified container
docker container kill <hash>         # Force shutdown of the specified container
docker container rm <hash>        # Remove specified container from this machine
docker container rm $(docker container ls -a -q)         # Remove all containers
docker image ls -a                             # List all images on this machine
docker image rm <image id>            # Remove specified image from this machine
docker image rm $(docker image ls -a -q)   # Remove all images from this machine
docker login             # Log in this CLI session using your Docker credentials
docker tag <image> username/repository:tag  # Tag <image> for upload to registry
docker push username/repository:tag            # Upload tagged image to registry
docker run username/repository:tag                   # Run image from a registry


docker stack ls                                            # List stacks or apps
docker stack deploy -c <composefile> <appname>  # Run the specified Compose file
docker service ls                 # List running services associated with an app
docker service ps <service>                  # List tasks associated with an app
docker inspect <task or container>                   # Inspect task or container
docker container ls -q                                      # List container IDs
docker stack rm <appname>                             # Tear down an application
docker swarm leave --force      # Take down a single node swarm from the manager


docker container ls --all


## List Docker CLI commands
docker
docker container --help

## Display Docker version and info
docker --version
docker version
docker info

## Execute Docker image
docker run hello-world

## List Docker images
docker image ls

## List Docker containers (running, all, all in quiet mode)
docker container ls
docker container ls --all
docker container ls -aq

Ctrl + P + Q = To exit container without killing it

1. Docker Pull <imagename>
	- Pull the image from web and download it to local.

3. Docker ps
	- To list running containers
4. Docker ps -a
	- To see previously run containers
5. Docker run -it <imagename> sh
	- To go inside container and run user defined commands
6. Docker kill $(docker ps -q)
	- Stop all containers:
7. Docker rm $(docker ps -a -q)
	- Remove all containers
8. Docker rmi $(docker images -q)
	- Remove all docker images


------------------------------------------------------------------
				ANSIBLE
------------------------------------------------------------------


Ansible host file location : /etc/ansible/hosts

ansible all -m ping
	- will ping all the hosts mentioned in hosts file and give the status






